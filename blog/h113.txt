2013年  9月 13日 金曜日 19:38:57 JST

javascript で OAuth認証する
それぞれのサービスにおけるOAuth認証を統括して利用できる
http://oauth-io.github.io/oauth-js/

このリンクをただメモするためだけの記事なんだけど余白がもったいないので
今現在，AtCoderにおいてjavascriptで書くために使っているテンプレを解説
してみたいと思います

テンプレは /js/template.js です．今現在のそれにコメントを大量に仕込む
ことを以って解説とします．

/* 入出力 */

print=console.log;

// 出力関数です．console.log では長いので print とします
// 注意することとして，printは最後に改行が勝手に一つ追加されること
// 改行を含まない出力関数は process.stdout.write ですが，
// 適当に文字列に置いといて print すればいいし．
// 特に AtCoder は出力の一番最後に改行が必要で忘れがちなので，勝手に改行を
// 追加されるのは，これに限っては便利です
// 
// もうひとつ
// 複数引数を渡すと，それぞれについて toString() で文字列にして，半角空白で
// joinしたもの＋改行を出力します
// print(1, 2);
// == print("1 2")
//
// ただ，正しい使い方としては，Cのprintfのようなフォーマット文字列の出力です
// print("%d %s", 4, "hoge")
// でも %d と %s しか無いみたい．%.3f みたいなのは無視される
// フォーマット文字列なんて使わないほうがいいね

ls=require("fs").readFileSync("/dev/stdin","utf-8").split("\n");ls.length--

// 入力を全部一旦読んでしまいます
// 行ごとに処理するのは分かりきっているので \n でsplitします
// あと最後に絶対空の行ができるので，lengthをデクリメントすることで，配列の
// 最後を削ってしまいます．これで，ls.lengthが入力の行数と一致しています

/* Object全般についていくつか */
op = Object.prototype;

op.toString = function(){
  var s=[];
  for(var i in this)if(this.hasOwnProperty(i))s=s.concat(i+":"+this[i]);
  return "{"+s.join(",")+"}" };

// Objectを文字列にキャストなんていうのは，デバッグでくらいしか使いません
// たいていの環境ではたぶん "[object Object]" とかそっけないものが返ってきて
// 使い物にならないので，上のようにすれば "{x:1, y:2}" などと中身が見られます

op.trace = function(x){
  process.stderr.write((x?(x+": "):"")+this+"\n"); return this };

// メソッドチェーンで使いやすいようなstderr出力関数です
// 最後に自身を返します

/* String 全般について */
sp = String.prototype;

sp.int = function(c){ return this.split(c||" ").map(int)};

// 主に，入力で得たデータをあとで使う為のものです．
// "22 32 42".int() === [22, 32, 42] に変換します．
// 中の int 関数は後述していますが，+"22" みたいに文字列を数にキャストする関数です

sp.count = function(sub){
  for (var c=i=0;i>=0;i=this.indexOf(sub,i+1),++c); return c };
// 文字列中にある文字列が何回現れるか

/* Array 全般 */
ap = Array.prototype;

ap.toString = function(){ return "["+this.join(",")+"]" };
// Object 同様に，例えば [1,2,3] という配列を "[1,2,3]" という文字列に
// 変換するものです．デフォルトのtoString()は二重になってたら意味が
// 分からなくなるので決して使ってはいけません

ap.max = function(){ return Math.max.apply(null, this) };
ap.min = function(){ return Math.min.apply(null, this) };
// Math.max, Math.min は可変長引数です
// [1,2,3].max() === Math.max(1,2,3)
// ちなみに，[1,2,3].reduce(Math.max) の結果は NaN です．地味に気をつけましょう

ap.sum = function(){ return this.reduce(add) };
ap.prod = function(){return this.reduce(mul) };
// 配列について和や積で畳み込みます

ap.copy = function(){ return this.map(id) };
// id は後述
// 配列は参照渡しなので，気をつけてコピーするときはコピーしましょう

ap.rotate = function(n){
  return this.slice(n||1,this.length).concat(this.slice(0,n||1)) };
// [1,2,3].rotate() === [2,3,1]
// デフォルトで1つ動かす

ap.shuffle = function(){
  return this.map(function(x){return [Math.random(),x]})
             .sort(function(a,b){return a[0]-b[0]})
             .map(function(x){return x[1]}) };
// 配列のランダムなシャッフル

ap.permutation = function(){
  if (this.length == 0) return [];
  if (this.length == 1) return [this];
  var ret=[], ar=this, i=0;
  for (; i<ar.length; ++i)
    ret=ret.concat(ar.slice(0, i)
           .concat(ar.slice(i+1, ar.length))
           .permutation()
           .map(function(p){ return p.concat(ar[i]) }))
  return ret };

// すべての並び替えを配列で返します
// [1,2,3].permutation === [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]

ap.flatten = function(){
  for (var i=0,r=[]; i<this.length; ++i) r=r.concat(this[i]); return r };

// 配列の平坦化
// [[1,2,3], [4,5,6]] === [1,2,3,4,5,6]
// 要するにconcatだね，これ
// flattenって名前はちょっと誤解を生みそうだ

ap.nub = function() {
  for (var r=[],u=[],v,i=0; i<this.length; ++i)
    if (!((v=this[i]) in u)) r=r.concat(v),u[v]=true; return r; }

// 重複する要素を一つだけ残して取り除く関数．uniq と呼んでもよいね
// [1,2, 3, 2, 3, 3].nub() === [1,2,3]

function iota(n,b,s){ b=b||0; s=s||1; for (var r=[];n--;b+=s) r.push(b); return r }
// SRFI-1やらJのイオタです
// iota(n) === [0, 1 .. n-1] (もちろん .. なんて文法はない)
// iota(n, b) === [b, b+1 .. b+n-1] (長さはn)
// iota(n, b, s) === [b, b+s .. b+(n-1)*s] (やはり長さはn)

// その他，見た通りの関数

function int(s){return +s}
function add(a,b){return a+b}
function mul(a,b){return a*b}
function sub(a,b){return a-b}
function bus(a,b){return b-a}
function id(x){return x}
function sq(x){return x*x}

// 精神衛生の為に，自分で書くコードはこの即時関数の中に書く
// 好きなときに return で大域脱出できるしね
(function main() {

})();

// vim: set ft=javascript:

個人的にメソッドチェーンで書くのが好きなので
.trace()
でエラー出力するのはデバグに大変役立ちます
間に挟めばいいだけなので

iota(n)
.permutate
.map(solve)
.max()

=>

iota(n)
.permutate
.map(solve)
.trace()
.max()

みたいなね
