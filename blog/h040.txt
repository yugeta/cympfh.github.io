Thu Feb 28 01:59:35 JST 2013

最近、義務のように、生涯使うつもりの言語であるかのように
Scheme、Gaucheばっかり使ってるなあ．オライリーのGaucheプログラミング
欲しいなあって思ってるし．

F#のパイプライン演算子、関数合成演算子．

gosh> (define (>> f g) (.$ g f))
gosh> (define (sq x) (* x x))
gosh> (define (inc x) (+ x 1))
gosh> (define f (>> inc sq))
gosh> (f 3)
16

Prelude> let (>>) f g = g . f
Prelude> let sq x = x*x
Prelude> let inc x = x+1
Prelude> let f = inc >> sq
Prelude> f 3
16
Prelude> let g = inc >> sq >> inc
Prelude> g 3
17

gosh> (define g (>> (>> inc sq) inc))
gosh> (g 3)
17

いや、これはあかんでしょ．

gosh> (define-syntax >>
(syntax-rules ()
  ((_ f g) (.$ g f))
  ((_ f g h ...) (>> (.$ g f) h ...)) ))
gosh> (define g (>> inc sq inc))
gosh> (g 3)
17

それより、ついつい
gosh> (define-syntax >>
(syntax-rules ()
  ((_ f g) (.$ g f))
  ((_ f g ...) (>> (.$ g f) ...)) ))
と書いてしまう．まだまだ慣れが足りない．
しかし、それでも何かしら定義は出来て、そうすると

gosh> (define g (>> inc sq inc))
gosh> (g 3)
18

となった．これは一体なんだ？
<< wakaran

Prelude> let (|>) x f = f x
Prelude> 2 |> inc |> sq |> sq
81

gosh> (define-syntax \>
(syntax-rules ()
  ((_ x f) (f x))
    ((_ x f g ...) (\> (f x) g ...)) ))
gosh> (\> 2 inc sq sq)
81

Schemeで|は使えない．へんちくりんな変数名を|で括るから．
gosh> (define |"| 1)
|"|
gosh> |"|
1
みたいにね．

Haskellみたいなの方が、コードが少なくなるのは知ってるんだよ．
まあ、どうせ趣味で使うんだから、その時々で好きなの使えばいいんだ．

もしかしてと思ってできたけど、.$は別に引数2つに限ってなかった．
そうか、LISPのLISPたる所以は、引数はたいていいくつでもいいんだ．
listをapplyしてるのが正しい形なんだから．

つまり、+という演算子は、Haskell含めてたいていは二項演算子だけど、
LISPだと、(+ 1 2 3 ...) というのが当たり前なんだよな．

gosh> (define h (.$ sq sq inc))
gosh> (h 2)
81

gosh> (define (>> . ls) (apply .$ (reverse ls)))
gosh> (define i (>> sq sq inc))
gosh> (i 2)
17

gosh> (define (\> x . ls) ((apply >> ls) x))
|\\>|
gosh> (\> 3 sq inc)
10

この\>は、>>が関数だからこそ定義できた．

define-syntaxは長くなるから嫌だな．define-macroってのもあるみたい
だけど、引数の数でmatchさせるようには出来てないみたいだし、
正直に言えば、LISPのマクロはなにがそんなにすごいのか分かってないです．
引数の評価を遅らせる版の関数で、あとcase-lambdaみたいなことができる、
くらいにしか．
