Thu Feb 28 11:08:28 JST 2013

そうそう、学校の課題でGCを実装した．調べたりで構想ができるまでに
2日くらいかかったけれど、実際のコーディングは5時間程度で、デバグ
まで出来た．
「世界初の記念すべきGCアルゴリズムはマークスイープGC[1]です．
はじめて世に出てから半世紀近くが経過した今も、様々な処理系で
用いられている偉大なアルゴリズムです．」---(「ガベージコレクション
のアルゴリズムと実装」中村成洋/相川光 共著 より)

長さ2000くらいの配列を延々と確保させてそれをゴミにするような
プログラムを動かす．初めはヒープの上に配列を上から作っていって、
残りが2000未満になったら、mark and sweep を行う．残り、というのは
    ヒープの限界 - ヒープレジスタ値
で計算する．mark sweepはヒープ上のゴミオブジェクトをゼロで塗りつぶす
作業．本当はフリーリストとして持っておくんだけど．でもこの作業の
後、ヒープレジスタ値は変わらない．だって、そうでしょう

         heap
  0 --+---------+
      | object  |
      +---------+
      | garbage |
      +---------+
      | object  |
      +---------+
      | object  |
reg_h-+---------+
      |         |
      |  empty  |
      :         :
limit +---------+

reg_hの値は、heapの上からつめていって、(一番上をゼロとして、アドレスが
増える方向を下としてる)、空なスペースの一番上のアドレスとしている．

mark and sweep をすると、先のヒープはこうなる．


         heap
  0 --+---------+
      | object  |
      +---------+
      |  empty  |
      +---------+
      | object  |
      +---------+
      | object  |
reg_h-+---------+
      |         |
      |  empty  |
      :         :
limit +---------+

ほら、間に空白が空いただけで、reg_hは変わらない．
だから、先の計算では、ヒープの残り容量は変わらないことになる．
従って、先ほど確保しようとしてGCを起こさせた配列確保を再び
しようとすると、またGCを起こす．またmark and sweep する．地味に
時間がかかる．まるで使い物にならない．

改良方法はいくらでも思いついたが、残念ながらヤル気が起きない．
それよりも、コンパイラ自体を書きなおしたい．少なくともOCamlとかいう
言語以外で．
