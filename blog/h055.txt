Sat Mar 16 13:09:15 JST 2013

やっとfayをインストールできた．
fay :: Haskell -> JavaScript

$ cabal install fay
ってすると
test-framework-th-0.2.4 depends on haskell-src-exts-1.13.5 which failed to install
とか言われて、すぐ上の行に happy 1.7以上が必要とか書いてて、でもhappy
はあって、すぐググってPATHに~/.cabal/bin/は追加して．それでもダメで．
しょうがナシに
# ln ~/.cabal/bin/happy /bin/
とかやって、ともかくfay入れれた．
fayのためのサンプルコードは、fayが全然開発段階なので、githubに置いてある
のを見たほうがよくて
https://github.com/faylang/fay/tree/master/examples

---
$ fay --version
fay 0.14.2.0

---
$ cat test.hs
module Alert where

import FFI
import Prelude

main :: Fay ()
main = alert $ "Hello, World!"

alert :: String -> Fay ()
alert = ffi "console.log(%1)"

$ fay -O -o test.js test.hs; node test.js
Hello, World!
---
print という関数は無いみたい．show はあって

---
先の該当箇所を
main :: Fay ()
main = alert $ show $ "Hello, World!"
とだけして、

$ fay -O -o test.js test.hs; node test.js
{"car":"H","cdr":{"car":"e","cdr":{"car":"l","cdr":{"car":"l","cdr":{"car":"o","cdr":{"car":",","cdr":{"car":" ","cdr":{"car":"W","cdr":{"car":"o","cdr":{"car":"r","cdr":{"car":"l","cdr":{"car":"d","cdr":{"car":"!","cdr":null}}}}}}}}}}}}}

ちゃんとStringが[Char]になってる．しかもたぶん、showはただの#toString
じゃなくて、オブジェクトの中身を列挙させてる．組み込みの#toStringは
使い物にならないからね．

---
型検査の為だけに、またその時だけに、ghcを使うそうです、fayは．

ああ、あと、console.logの型をString->Fay ()としてるけど、a->Fay () と
してしまって良いって、思ったんだけど、なんか不可思議なことになるので
やめます．
---
まあ、はっきり言って使い物にならない．そのまま通せば型検査通って
欲しいようなものも通らないし．いや、まあ、私が使いこなせてない
だけだろうけど．fayはHaskellじゃなくてHaskellのようなものを
扱うものらしい．

---
$ cat test.hs
module Alert where

import FFI
import Prelude

main :: Fay ()
main = alert $ show $ a
    where
    a :: [Int]
    a =  map (\x -> x*x) [1,2,3]

alert :: String -> Fay ()
alert = ffi "console.log(%1)"

$ fay -O -o test.js test.hs; node test.js
{"car":{"forced":false},"cdr":{"forced":false}}

---
あー、遅延されてるのか．
出力の前に中身を評価させればいいんだろう．

---
cympfh@yuugiri:~/test$ cat test.hs
module Alert where

import FFI
import Prelude

main :: Fay ()
main = alert $ show_list $ a
    where
        a :: [Int]
        a =  map (\x -> x*x) [1,2,3]

alert :: String -> Fay ()
alert = ffi "console.log(%1)"

show_list :: [a] -> String
show_list ls = "[" ++ show_list' ls ++ "]"
show_list' ls =
    case ls of
      [] -> ""
      x:xs -> (show x) ++ ", " ++ (show_list' xs)

cympfh@yuugiri:~/test$ make
fay -O -o test.js test.hs
node test.js
[1, 4, 9, ]

まあ、こんなもんで．

---
case of 使ってるけど、引数でのパターンマッチはできなかった．

cympfh@yuugiri:~/test$ cat test.hs
module Alert where

import FFI
import Prelude

main :: Fay ()
main = alert $ show $ fact 10
    where

	fact :: Int -> Int
	fact 0 = 1
	fact n = n * (fact (n-1))

alert :: String -> Fay ()
alert = ffi "console.log(%1)"

cympfh@yuugiri:~/test$ make
fay -O -o test.js test.hs
node test.js
3628800

なんか、出来るようになってしまった．いみふ．

さっきなんか ambiguous type を連呼してたくせに．わけわからん

---
cympfh@yuugiri:~/test$ cat test.hs
module Alert where

import FFI
import Prelude

main :: Fay ()
main = alert $ show $ fact 10
    where

	fact 0 = 1
	fact n = n * fact (n-1)

alert :: String -> Fay ()
alert = ffi "console.log(%1)"

cympfh@yuugiri:~/test$ make
fay -O -o test.js test.hs
fay:
test.hs:7:23:
	Ambiguous type variable `a0' in the constraints:
	  (Eq (Automatic a0)) arising from a use of `fact' at test.hs:7:23-26
	  (base:GHC.Num.Num (Automatic a0))
		arising from the literal `10' at test.hs:7:28-29
	  (Prelude.Num (Automatic a0))
		arising from a use of `fact' at test.hs:7:23-26
	Probable fix: add a type signature that fixes these type variable(s)
	In the second argument of `($)', namely `fact 10'
	In the second argument of `($)', namely `show $ fact 10'
	In the expression: alert $ show $ fact 10

make: *** [test] Error 1


できた．できない例が．
factの型を明記してやると動く．なんで型検査通らないのかな
