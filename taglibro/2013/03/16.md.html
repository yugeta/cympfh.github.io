<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title></title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../../css/h1.css">
</head>
<body>
<p>Sat Mar 16 11:27:39 JST 2013</p>
<pre><code>; :vim set wildmode=longest,list,full:</code></pre>
<p>資本主義の理念が原因で、家のネットが使えなくなった<br>心の中で思わずやったぁと喜んだ．これで自分の時間が<br>できるぞ！毎月4000円払う権利を放棄して、自由を得た．</p>
<p>だってだってだって</p>
<p>以下、食堂で聞いた会話．</p>
<p>今不安になってU-task見てきたけど無事進級してた<br>なりさんおはようございます<br>もう1件いったら遅刻じゃねーかクソ<br>病院に春って感じのフリルな服着てきたらめっちゃ見られた。<br>クソゲーだからです<br>とりあえず5月までは忙しい<br>もうちょいこっちいて荷物の片付け追い込んでも良いんだけど、そ うすると本当に展覧会周り切れなくなる<br>やっぱり闘ってる企業人は顔が違うな，それに比べ俺は凧の切れた 糸みたいな感じだわ<br>姉くれ<br>ああああああああああああああああああああああああああああああ あああああああああああああああああああああああ<br>押上行多いな<br>ぷよぷよ×おにゃのことかうわぁ</p>
<hr>
<p>Sat Mar 16 13:09:15 JST 2013</p>
<p>やっとfayをインストールできた． <code>fay :: Haskell -&gt; JavaScript</code></p>
<p><code>bash $ cabal install fay</code> ってすると <code>test-framework-th-0.2.4 depends on haskell-src-exts-1.13.5 which failed to install</code> とか言われて、すぐ上の行に happy 1.7以上が必要とか書いてて、でもhappy はあって、すぐググってPATHに~/.cabal/bin/は追加して．それでもダメで． しょうがナシに <code>bash # ln ~/.cabal/bin/happy /bin/</code> とかやって、ともかくfay入れれた． fayのためのサンプルコードは、fayが全然開発段階なので、githubに置いてある のを見たほうがよくて https://github.com/faylang/fay/tree/master/examples</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ fay --version
fay 0.14.2.0</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> test.hs
module Alert where

import FFI
import Prelude

main :: <span class="fu">Fay ()</span>
main = alert $ <span class="st">&quot;Hello, World!&quot;</span>

alert :: String -<span class="kw">&gt;</span> <span class="fu">Fay ()</span>
alert = ffi <span class="st">&quot;console.log(%1)&quot;</span>

$ fay -O -o test.js test.hs; node test.js
Hello, World!</code></pre>
<p>print という関数は無いみたい．show はあって</p>
<p>先の該当箇所を <code>haskell main :: Fay () main = alert $ show $ &quot;Hello, World!&quot;</code> とだけして、</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ fay -O -o test.js test.hs; node test.js
{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;H&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;e&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;l&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;l&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;o&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;,&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot; &quot;</span>,<span class="st">&quot;cdr&quot;</span>:<span class="dt">{&quot;car&quot;:&quot;W&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;o&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;r&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;l&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;d&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;!&quot;,&quot;cdr&quot;:null}}}}}}}}}}}}}</span></code></pre>
<p>ちゃんとStringが[Char]になってる．しかもたぶん、showはただの#toString じゃなくて、オブジェクトの中身を列挙させてる．組み込みの#toStringは 使い物にならないからね．</p>
<hr>
<p>型検査の為だけに、またその時だけに、ghcを使うそうです、fayは．</p>
<p>ああ、あと、console.logの型を<code>String-&gt;Fay ()</code>としてるけど、<code>a-&gt;Fay ()</code>と してしまって良いって、思ったんだけど、なんか不可思議なことになるのでやめます．</p>
<hr>
<p>はっきり言って使い物にならない．そのまま通せば型検査通って 欲しいようなものも通らないし．いや、まあ、私が使いこなせてない だけだろうけど．fayはHaskellじゃなくてHaskellのようなものを 扱うものらしい．</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Alert</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">FFI</span>
<span class="kw">import</span> <span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> alert <span class="fu">$</span> <span class="fu">show</span> <span class="fu">$</span> a
    <span class="kw">where</span>
<span class="ot">    a ::</span> [<span class="dt">Int</span>]
    a <span class="fu">=</span>  <span class="fu">map</span> (\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

<span class="ot">alert ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
alert <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span></code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ fay -O -o test.js test.hs; node test.js
<span class="dt">{&quot;car&quot;:{&quot;forced&quot;:false},&quot;cdr&quot;:{&quot;forced&quot;:false}}</span></code></pre>
<p>あー、遅延されてるのか． 出力の前に中身を評価させればいいんだろう．</p>
<pre class="hsakell"><code>module Alert where

import FFI
import Prelude

main :: Fay ()
main = alert $ show_list $ a
    where
        a :: [Int]
        a =  map (\x -&gt; x*x) [1,2,3]

alert :: String -&gt; Fay ()
alert = ffi &quot;console.log(%1)&quot;

show_list :: [a] -&gt; String
show_list ls = &quot;[&quot; ++ show_list&#39; ls ++ &quot;]&quot;
show_list&#39; ls =
    case ls of
      [] -&gt; &quot;&quot;
      x:xs -&gt; (show x) ++ &quot;, &quot; ++ (show_list&#39; xs)</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">fay -O -o test.js test.hs
node test.js
[1, 4, 9, ]</code></pre>
<p>まあ、こんなもんで．</p>
<hr>
<p>case of 使ってるけど、引数でのパターンマッチはできなかった．</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Alert</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">FFI</span>
<span class="kw">import</span> <span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> alert <span class="fu">$</span> <span class="fu">show</span> <span class="fu">$</span> fact <span class="dv">10</span>
    <span class="kw">where</span>

<span class="ot">    fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
    fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
    fact n <span class="fu">=</span> n <span class="fu">*</span> (fact (n<span class="dv">-1</span>))

<span class="ot">alert ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
alert <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span></code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">fay -O -o test.js test.hs
node test.js
3628800</code></pre>
<p>なんか、出来るようになってしまった．いみふ．</p>
<p>さっきなんか ambiguous type を連呼してたくせに．わけわからん</p>
<hr>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Alert</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">FFI</span>
<span class="kw">import</span> <span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> alert <span class="fu">$</span> <span class="fu">show</span> <span class="fu">$</span> fact <span class="dv">10</span>
    <span class="kw">where</span>

    fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
    fact n <span class="fu">=</span> n <span class="fu">*</span> fact (n<span class="dv">-1</span>)

<span class="ot">alert ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
alert <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span></code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">fay -O -o test.js test.hs
fay:
test.hs:7:23:
    Ambiguous <span class="kw">type</span> variable <span class="kw">`</span>a0<span class="st">&#39; in the constraints:</span>
<span class="st">      (Eq (Automatic a0)) arising from a use of `fact&#39;</span> at test.hs:7:23-26
      <span class="kw">(</span>base:GHC.Num.Num <span class="kw">(</span>Automatic a0<span class="kw">))</span>
        arising from the literal <span class="kw">`</span>10<span class="st">&#39; at test.hs:7:28-29</span>
<span class="st">      (Prelude.Num (Automatic a0))</span>
<span class="st">        arising from a use of `fact&#39;</span> at test.hs:7:23-26
    Probable fix: add a <span class="kw">type</span> signature that fixes these <span class="kw">type</span> variable<span class="kw">(</span>s<span class="kw">)</span>
    In the second argument of <span class="kw">`(</span>$<span class="kw">)</span><span class="st">&#39;, namely `fact 10&#39;</span>
    In the second argument of <span class="kw">`(</span>$<span class="kw">)</span><span class="st">&#39;, namely `show $ fact 10&#39;</span>
    In the expression: alert $ show $ fact 10

make: *** [test] Error 1</code></pre>
<p>できた．できない例が． factの型を明記してやると動く．なんで型検査通らないのかな</p>
<hr>
<p>Sat Mar 16 13:50:18 JST 2013</p>
<p>もうちょっと、Fayで遊ぶ． こっちから歩み寄る姿勢が大切．</p>
<p>まず公式のドキュメントを正座して朗読する． <a href="https://github.com/faylang/fay/wiki">Home · faylang/fay Wiki</a></p>
<blockquote>
<p>A proper subset of Haskell that compiles to JavaScript.</p>
</blockquote>
<p>はい．subsetなのですね．気をつけます．</p>
<p>前回、printが無いとか言ったけど、putStrLnならあった． console.logであると中で定義されてる．show関数はJSONへの変換程度． リストなんかを綺麗に表示するのは自分の手でやるのかな．</p>
<p>なにをどう変換してから型検査に掛けてるのかわからん．</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">FFI</span>
<span class="kw">import</span> <span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">$</span> list_show <span class="fu">$</span> [ i <span class="fu">|</span> i <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]

<span class="ot">list_show ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
list_show ls <span class="fu">=</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> list_show&#39; ls <span class="fu">++</span> <span class="st">&quot;]&quot;</span>
list_show&#39; [] <span class="fu">=</span> <span class="st">&quot;&quot;</span>
list_show&#39; (x<span class="fu">:</span>[]) <span class="fu">=</span> <span class="fu">show</span> x
list_show&#39; (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="fu">show</span> x <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> list_show&#39; xs</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">fay -O -o test.js test.hs
fay:
test.hs:5:19:
    Couldn<span class="st">&#39;t match expected type `Char&#39;</span> with actual <span class="kw">type</span> <span class="kw">`</span>Int<span class="st">&#39;</span>
<span class="st">    Expected type: [Int] -&gt; fay-base-0.14.2.0:Prelude.String</span>
<span class="st">        Actual type: [Int] -&gt; [Int]</span>
<span class="st">    In the first argument of `($)&#39;</span>, namely <span class="kw">`</span>list_show<span class="st">&#39;</span>
<span class="st">    In the second argument of `($)&#39;</span>, namely
        <span class="kw">`</span>list_show $ [i <span class="kw">|</span> i <span class="kw">&lt;</span>- [1, 2, 3]]<span class="st">&#39;</span>

<span class="st">test.hs:8:16:</span>
<span class="st">    Couldn&#39;</span>t match expected <span class="kw">type</span> <span class="kw">`</span>Int<span class="st">&#39; with actual type `Char&#39;</span>
    Expected type: [Int]
        Actual type: [Char]
    In the first argument of <span class="kw">`(</span>++<span class="kw">)</span><span class="st">&#39;, namely `&quot;[&quot;&#39;</span>
    In the expression: <span class="st">&quot;[&quot;</span> ++ list_show<span class="st">&#39; ls ++ &quot;]&quot;</span>

<span class="st">make: *** [test] Error 1</span></code></pre>
<table>
<col style="width: 4%" /><tbody>
<tr class="odd">
<td style="text-align: left;">Sat Mar 16 19:44:42 JST 2013</td>
</tr>
<tr class="even">
<td style="text-align: left;">ああ、もういいです．もう満足しました</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="http://d.hatena.ne.jp/podhmo/20101217/1292565023">部分継続便利だなー。 - podhmoの日記</a></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>scheme gosh&gt; (define k #f) k gosh&gt; (reset (for-each (^x (shift cc (set! k cc) x)) (list 1 2 3))) 1 gosh&gt; (k) 2 gosh&gt; (k) 3 gosh&gt; (k) #&lt;undef&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">ええっと、reset-shiftで作った継続は引数を取らないのね．まずそこから 初めて知った．で、これの有用性は、既にそこにあるループを中断、再開 させること．再帰なんかでこれを実現するには、中身が使ってるパラメータ なんかを全部、再帰の引数にして、中断・再開にはそのパラメータは保存 しておくのだろう．それらをパッと実現できるので、継続は有用である． ということかな．</td>
</tr>
</tbody>
</table>
<p><a href="http://outer-inside.blogspot.jp/2011/03/blog-post.html">部分継続チュートリアル</a></p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">gosh&gt; (<span class="kw">cons</span> <span class="dv">0</span> (reset (<span class="kw">cons</span> <span class="dv">1</span> (shift k (<span class="kw">cons</span> <span class="dv">2</span> &#39;null )))))
(<span class="dv">0</span> <span class="dv">2</span> . null)
gosh&gt; k
#&lt;closure (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)<span class="kw">&gt;</span>
gosh&gt; (<span class="kw">cons</span> <span class="dv">0</span> (reset (<span class="kw">cons</span> <span class="dv">1</span> (shift cc (set! k cc) (<span class="kw">cons</span> <span class="dv">2</span> &#39;null )))))
(<span class="dv">0</span> <span class="dv">2</span> . null)
gosh&gt; k
#&lt;closure (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)<span class="kw">&gt;</span>
gosh&gt; (k <span class="dv">3</span>)
(<span class="dv">1</span> . <span class="dv">3</span>)
gosh&gt; (k)
(<span class="dv">1</span> . #&lt;undef&gt;)</code></pre>
<p>引数とるじゃん．取らなくても何かにはなるのね</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">gosh&gt; (d k)
#&lt;closure (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)<span class="kw">&gt;</span> is an instance of class &lt;procedure&gt;
slots:
  required  : <span class="dv">0</span>
  optional  : <span class="dv">#t</span>
  optcount  : <span class="dv">1</span>
  locked    : <span class="dv">#f</span>
  currying  : <span class="dv">#f</span>
  constant  : <span class="dv">#f</span>
  info      : (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)
  setter    : <span class="dv">#f</span></code></pre>
<p>うん、まあ、わからん．</p>
<hr>
<p><a href="http://practical-scheme.net/gauche/man/gauche-refj_94.html">Gauche ユーザリファレンス: 9.20 gauche.partcont - 部分継続</a></p>
<p>初めからココ読むんだった． 分かった気にはなった． そして、ループの外側と内側をreset-shiftで挟むことで、ループを一周だけ 回すような継続が取り出せる、んだろう．</p>
</body>
</html>
