<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../../css/h1.css" type="text/css" />
</head>
<body>
<p>Sat Mar 16 11:27:39 JST 2013</p>
<pre><code>; :vim set wildmode=longest,list,full:</code></pre>
<p>資本主義の理念が原因で、家のネットが使えなくなった<br />心の中で思わずやったぁと喜んだ．これで自分の時間が<br />できるぞ！毎月4000円払う権利を放棄して、自由を得た．</p>
<p>だってだってだって</p>
<p>以下、食堂で聞いた会話．</p>
<p>今不安になってU-task見てきたけど無事進級してた<br />なりさんおはようございます<br />もう1件いったら遅刻じゃねーかクソ<br />病院に春って感じのフリルな服着てきたらめっちゃ見られた。<br />クソゲーだからです<br />とりあえず5月までは忙しい<br />もうちょいこっちいて荷物の片付け追い込んでも良いんだけど、そ うすると本当に展覧会周り切れなくなる<br />やっぱり闘ってる企業人は顔が違うな，それに比べ俺は凧の切れた 糸みたいな感じだわ<br />姉くれ<br />ああああああああああああああああああああああああああああああ あああああああああああああああああああああああ<br />押上行多いな<br />ぷよぷよ×おにゃのことかうわぁ</p>
<hr />
<p>Sat Mar 16 13:09:15 JST 2013</p>
<p>やっとfayをインストールできた． <code>fay :: Haskell -&gt; JavaScript</code></p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install fay</code></pre>
<p>ってすると</p>
<pre><code>test-framework-th-0.2.4 depends on haskell-src-exts-1.13.5 which failed to install</code></pre>
<p>とか言われて、すぐ上の行に happy 1.7以上が必要とか書いてて、でもhappy はあって、すぐググってPATHに~/.cabal/bin/は追加して．それでもダメで． しょうがナシに</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># ln ~/.cabal/bin/happy /bin/</span></code></pre>
<p>とかやって、ともかくfay入れれた． fayのためのサンプルコードは、fayが全然開発段階なので、githubに置いてある のを見たほうがよくて https://github.com/faylang/fay/tree/master/examples</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">fay</span> --version
<span class="kw">fay</span> 0.14.2.0</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cat</span> test.hs
<span class="kw">module</span> Alert where

<span class="kw">import</span> FFI
<span class="kw">import</span> Prelude

<span class="kw">main</span> :: Fay ()
<span class="kw">main</span> = alert $ <span class="st">&quot;Hello, World!&quot;</span>

<span class="kw">alert</span> :: String -<span class="kw">&gt;</span> Fay ()
<span class="kw">alert</span> = ffi <span class="st">&quot;console.log(%1)&quot;</span>

$ <span class="kw">fay</span> -O -o test.js test.hs<span class="kw">;</span> <span class="kw">node</span> test.js
<span class="kw">Hello</span>, World!</code></pre>
<p>print という関数は無いみたい．show はあって</p>
<p>先の該当箇所を</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> alert <span class="fu">$</span> show <span class="fu">$</span> <span class="st">&quot;Hello, World!&quot;</span></code></pre>
<p>とだけして、</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">fay</span> -O -o test.js test.hs<span class="kw">;</span> <span class="kw">node</span> test.js
{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;H&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;e&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;l&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;l&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;o&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot;,&quot;</span>,<span class="st">&quot;cdr&quot;</span>:{<span class="st">&quot;car&quot;</span>:<span class="st">&quot; &quot;</span>,<span class="st">&quot;cdr&quot;</span>:<span class="dt">{&quot;car&quot;:&quot;W&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;o&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;r&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;l&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;d&quot;,&quot;cdr&quot;:{&quot;car&quot;:&quot;!&quot;,&quot;cdr&quot;:null}}}}}}}}}}}}}</span></code></pre>
<p>ちゃんとStringが[Char]になってる．しかもたぶん、showはただの#toString じゃなくて、オブジェクトの中身を列挙させてる．組み込みの#toStringは 使い物にならないからね．</p>
<hr />
<p>型検査の為だけに、またその時だけに、ghcを使うそうです、fayは．</p>
<p>ああ、あと、console.logの型を<code>String-&gt;Fay ()</code>としてるけど、<code>a-&gt;Fay ()</code>と してしまって良いって、思ったんだけど、なんか不可思議なことになるのでやめます．</p>
<hr />
<p>はっきり言って使い物にならない．そのまま通せば型検査通って 欲しいようなものも通らないし．いや、まあ、私が使いこなせてない だけだろうけど．fayはHaskellじゃなくてHaskellのようなものを 扱うものらしい．</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Alert</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">FFI</span>
<span class="kw">import </span><span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> alert <span class="fu">$</span> show <span class="fu">$</span> a
    <span class="kw">where</span>
<span class="ot">    a ::</span> [<span class="dt">Int</span>]
    a <span class="fu">=</span>  map (\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

<span class="ot">alert ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
alert <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span></code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">fay</span> -O -o test.js test.hs<span class="kw">;</span> <span class="kw">node</span> test.js
<span class="dt">{&quot;car&quot;:{&quot;forced&quot;:false},&quot;cdr&quot;:{&quot;forced&quot;:false}}</span></code></pre>
<p>あー、遅延されてるのか． 出力の前に中身を評価させればいいんだろう．</p>
<pre class="hsakell"><code>module Alert where

import FFI
import Prelude

main :: Fay ()
main = alert $ show_list $ a
    where
        a :: [Int]
        a =  map (\x -&gt; x*x) [1,2,3]

alert :: String -&gt; Fay ()
alert = ffi &quot;console.log(%1)&quot;

show_list :: [a] -&gt; String
show_list ls = &quot;[&quot; ++ show_list&#39; ls ++ &quot;]&quot;
show_list&#39; ls =
    case ls of
      [] -&gt; &quot;&quot;
      x:xs -&gt; (show x) ++ &quot;, &quot; ++ (show_list&#39; xs)</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">fay</span> -O -o test.js test.hs
<span class="kw">node</span> test.js
[<span class="kw">1</span>, 4, 9, ]</code></pre>
<p>まあ、こんなもんで．</p>
<hr />
<p>case of 使ってるけど、引数でのパターンマッチはできなかった．</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Alert</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">FFI</span>
<span class="kw">import </span><span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> alert <span class="fu">$</span> show <span class="fu">$</span> fact <span class="dv">10</span>
    <span class="kw">where</span>

<span class="ot">    fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
    fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
    fact n <span class="fu">=</span> n <span class="fu">*</span> (fact (n<span class="fu">-</span><span class="dv">1</span>))

<span class="ot">alert ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
alert <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span></code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">fay</span> -O -o test.js test.hs
<span class="kw">node</span> test.js
<span class="kw">3628800</span></code></pre>
<p>なんか、出来るようになってしまった．いみふ．</p>
<p>さっきなんか ambiguous type を連呼してたくせに．わけわからん</p>
<hr />
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Alert</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">FFI</span>
<span class="kw">import </span><span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> alert <span class="fu">$</span> show <span class="fu">$</span> fact <span class="dv">10</span>
    <span class="kw">where</span>

    fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
    fact n <span class="fu">=</span> n <span class="fu">*</span> fact (n<span class="fu">-</span><span class="dv">1</span>)

<span class="ot">alert ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
alert <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span></code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">fay</span> -O -o test.js test.hs
<span class="kw">fay</span>:
<span class="kw">test.hs</span>:7:23:
    <span class="kw">Ambiguous</span> type variable <span class="kw">`a0</span><span class="st">&#39; in the constraints:</span>
<span class="st">      (Eq (Automatic a0)) arising from a use of `fact&#39;</span> at test.hs:7:23-26
      <span class="kw">(base</span>:GHC.Num.Num (Automatic a0<span class="kw">)</span>)
        <span class="kw">arising</span> from the literal <span class="kw">`</span>10<span class="st">&#39; at test.hs:7:28-29</span>
<span class="st">      (Prelude.Num (Automatic a0))</span>
<span class="st">        arising from a use of `fact&#39;</span> at test.hs:7:23-26
    <span class="kw">Probable</span> fix: add a type signature that fixes these type variable(s)
    <span class="kw">In</span> the second argument of <span class="kw">`(</span>$<span class="kw">)</span><span class="st">&#39;, namely `fact 10&#39;</span>
    <span class="kw">In</span> the second argument of <span class="kw">`</span>($)<span class="st">&#39;, namely `show $ fact 10&#39;</span>
    <span class="kw">In</span> the expression: alert $ show $ fact 10

<span class="kw">make</span>: *** [test] Error 1</code></pre>
<p>できた．できない例が． factの型を明記してやると動く．なんで型検査通らないのかな</p>
<hr />
<p>Sat Mar 16 13:50:18 JST 2013</p>
<p>もうちょっと、Fayで遊ぶ． こっちから歩み寄る姿勢が大切．</p>
<p>まず公式のドキュメントを正座して朗読する． <a href="https://github.com/faylang/fay/wiki">Home · faylang/fay Wiki</a></p>
<blockquote>
<p>A proper subset of Haskell that compiles to JavaScript.</p>
</blockquote>
<p>はい．subsetなのですね．気をつけます．</p>
<p>前回、printが無いとか言ったけど、putStrLnならあった． console.logであると中で定義されてる．show関数はJSONへの変換程度． リストなんかを綺麗に表示するのは自分の手でやるのかな．</p>
<p>なにをどう変換してから型検査に掛けてるのかわからん．</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">FFI</span>
<span class="kw">import </span><span class="dt">Prelude</span>

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> putStrLn <span class="fu">$</span> list_show <span class="fu">$</span> [ i <span class="fu">|</span> i <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]

<span class="ot">list_show ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
list_show ls <span class="fu">=</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> list_show&#39; ls <span class="fu">++</span> <span class="st">&quot;]&quot;</span>
list_show&#39; [] <span class="fu">=</span> <span class="st">&quot;&quot;</span>
list_show&#39; (x<span class="fu">:</span>[]) <span class="fu">=</span> show x
list_show&#39; (x<span class="fu">:</span>xs) <span class="fu">=</span> show x <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> list_show&#39; xs</code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">fay</span> -O -o test.js test.hs
<span class="kw">fay</span>:
<span class="kw">test.hs</span>:5:19:
    <span class="kw">Couldn</span><span class="st">&#39;t match expected type `Char&#39;</span> with actual type <span class="kw">`Int</span><span class="st">&#39;</span>
<span class="st">    Expected type: [Int] -&gt; fay-base-0.14.2.0:Prelude.String</span>
<span class="st">        Actual type: [Int] -&gt; [Int]</span>
<span class="st">    In the first argument of `($)&#39;</span>, namely <span class="kw">`</span>list_show<span class="st">&#39;</span>
<span class="st">    In the second argument of `($)&#39;</span>, namely
        <span class="kw">`list_show</span> $ [i <span class="kw">|</span> <span class="kw">i</span> <span class="kw">&lt;</span>- [1, 2, 3]]<span class="st">&#39;</span>

<span class="st">test.hs:8:16:</span>
<span class="st">    Couldn&#39;</span>t match expected type <span class="kw">`Int</span><span class="st">&#39; with actual type `Char&#39;</span>
    <span class="kw">Expected</span> type: [Int]
        <span class="kw">Actual</span> type: [Char]
    <span class="kw">In</span> the first argument of <span class="kw">`(++)</span><span class="st">&#39;, namely `&quot;[&quot;&#39;</span>
    <span class="kw">In</span> the expression: <span class="st">&quot;[&quot;</span> ++ list_show<span class="st">&#39; ls ++ &quot;]&quot;</span>

<span class="st">make: *** [test] Error 1</span></code></pre>
<p><a href="http://outer-inside.blogspot.jp/2011/03/blog-post.html">部分継続チュートリアル</a></p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">gosh&gt; (<span class="kw">cons</span> <span class="dv">0</span> (reset (<span class="kw">cons</span> <span class="dv">1</span> (shift k (<span class="kw">cons</span> <span class="dv">2</span> &#39;null )))))
(<span class="dv">0</span> <span class="dv">2</span> . null)
gosh&gt; k
#&lt;closure (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)<span class="kw">&gt;</span>
gosh&gt; (<span class="kw">cons</span> <span class="dv">0</span> (reset (<span class="kw">cons</span> <span class="dv">1</span> (shift cc (set! k cc) (<span class="kw">cons</span> <span class="dv">2</span> &#39;null )))))
(<span class="dv">0</span> <span class="dv">2</span> . null)
gosh&gt; k
#&lt;closure (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)<span class="kw">&gt;</span>
gosh&gt; (k <span class="dv">3</span>)
(<span class="dv">1</span> . <span class="dv">3</span>)
gosh&gt; (k)
(<span class="dv">1</span> . #&lt;undef&gt;)</code></pre>
<p>引数とるじゃん．取らなくても何かにはなるのね</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">gosh&gt; (d k)
#&lt;closure (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)<span class="kw">&gt;</span> is an instance of class &lt;procedure&gt;
slots:
  required  : <span class="dv">0</span>
  optional  : <span class="dv">#t</span>
  optcount  : <span class="dv">1</span>
  locked    : <span class="dv">#f</span>
  currying  : <span class="dv">#f</span>
  constant  : <span class="dv">#f</span>
  info      : (call/pc <span class="dv">#f</span> <span class="dv">#f</span>)
  setter    : <span class="dv">#f</span></code></pre>
<p>うん、まあ、わからん．</p>
<hr />
<p><a href="http://practical-scheme.net/gauche/man/gauche-refj_94.html">Gauche ユーザリファレンス: 9.20 gauche.partcont - 部分継続</a></p>
<p>初めからココ読むんだった． 分かった気にはなった． そして、ループの外側と内側をreset-shiftで挟むことで、ループを一周だけ 回すような継続が取り出せる、んだろう．</p>
</body>
</html>
