#
go
実験
```
sh
19
:
03
:
47
test
$
time
gosh
test
.
scm
354224848179261915075
real
0
m
0
.
027
s
user
0
m
0
.
008
s
sys
0
m
0
.
008
s
19
:
04
:
02
test
$
time
gosh
test
.
scm
354224848179261915075
real
0
m
0
.
029
s
user
0
m
0
.
008
s
sys
0
m
0
.
012
s
19
:
04
:
05
test
$
time
runghc
test
.
hs
354224848179261915075
real
0
m
0
.
189
s
user
0
m
0
.
160
s
sys
0
m
0
.
030
s
19
:
04
:
13
test
$
time
runghc
test
.
hs
354224848179261915075
real
0
m
0
.
188
s
user
0
m
0
.
172
s
sys
0
m
0
.
018
s
19
:
04
:
15
test
$
time
go
run
test
.
go
3736710778780434371
real
0
m
0
.
171
s
user
0
m
0
.
146
s
sys
0
m
0
.
027
s
19
:
04
:
20
test
$
time
go
run
test
.
go
3736710778780434371
real
0
m
0
.
159
s
user
0
m
0
.
136
s
sys
0
m
0
.
025
s
```
Go
動的
型付け
言語
答え
の
int
64
```
scheme
(
define
(
fib
a
b
n
)
(
if
(
zero
?
n
)
a
(
fib
b
(+
a
b
)
(-
n
1
))))
(
display
(
fib
0
1
100
))
```
```
haskell
import
Data
.
List
import
Data
.
Char
import
Data
.
Maybe
import
Data
.
Tuple
import
Debug
.
Trace
import
Data
.
Array
import
Data
.
Array
.
IO
import
Control
.
Monad
import
Control
.
Applicative
import
Control
.
Arrow
import
qualified
Data
.
ByteString
.
Char
8
as
B
import
qualified
Data
.
Map
as
M
import
qualified
Data
.
Set
as
S
import
Text
.
Printf
readInt
::
B
.
ByteString
->
Int
readInt
=
fst
.
fromJust
.
B
.
readInt
readInt
2
::
B
.
ByteString
->
(
Int
,
Int
)
readInt
2
=
l
2
t
.
map
readInt
.
B
.
words
readInt
3
::
B
.
ByteString
->
((
Int
,
Int
),
Int
)
readInt
3
=
l
3
t
.
map
readInt
.
B
.
words
l
2
t
[
x
,
y
]
=
(
x
,
y
)
l
3
t
[
x
,
y
,
z
]
=
((
x
-
1
,
y
-
1
),
z
)
(|>)
x
f
=
f
x
;
infixl
1
|>
car
=
head
cdr
=
tail
cadr
=
car
.
cdr
cddr
=
cdr
.
cdr
caddr
=
car
.
cddr
type
Cost
=
M
.
Map
(
Int
,
Int
)
Int
main
::
IO
()
main
=
do
let
fibs
=
iterate
(\(
a
,
b
)
->
(
b
,
a
+
b
))
(
0
,
1
)
print
$
fst
$
fibs
!!
100
```
```
go
package
main
import
(
"
fmt
"
)
func
main
()
{
var
x
,
y
int
64
x
=
0
y
=
1
for
i
:=
0
;
i
<
100
;
i
++
{
x
,
y
=
y
,
x
+
y
}
fmt
.
Println
(
x
)
}
```
["
An
experimental
package
in
Go
for
mixed
mode
arithmetic
including
rational
numbers
](
http
://
www
.
oki
-
osk
.
jp
/
esc
/
golang
/
arith
.
html
)
ー
`
golang
倍長
`
ググ
OKI
ページ
---
```
19
:
13
:
57
test
$
time
runghc
test
.
hs
354224848179261915075
real
0
m
0
.
130
s
user
0
m
0
.
105
s
sys
0
m
0
.
026
s
19
:
13
:
58
test
$
time
runghc
test
.
hs
354224848179261915075
real
0
m
0
.
128
s
user
0
m
0
.
108
s
sys
0
m
0
.
022
s
```
1
.
44
倍
速
```
haskell
main
::
IO
()
main
=
do
let
fibs
=
iterate
(\(
a
,
b
)
->
(
b
,
a
+
b
))
(
0
,
1
)
print
$
fst
$
fibs
!!
100
```
