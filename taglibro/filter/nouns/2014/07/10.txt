2014
年
7
月
10
日
木曜日
03
:
46
:
05
JST
===
#
リスト
内包
表記
scheme
リスト
内包
表記
srfi
-
42
.
一時期
42
番号
Haskell
リスト
内包
表記
スタンダート
リスト
内包
表記
次
よう
言語
```
List
-
comprehension
::=
[
Expression
|
Patterns
]
Patterns
::=
Pattern
|
Pattern
,
Patterns
Pattern
::=
Var
<-
List
|
let
Var
=
Var
|
Predicate
```
```
haskell
[(
x
,
y
,
z
)
|
x
<-
[
0
,
1
,
2
],
y
<-
"
abc
",
odd
x
,
let
z
=
(
x
,
y
)]
```
```
haskell
[(
1
,'
a
',(
1
,'
a
')),(
1
,'
b
',(
1
,'
b
')),(
1
,'
c
',(
1
,'
c
'))]
```
評価
`<-`
`
map
`
表現
`
let
`
`
let
`
#
リスト
私
昔
[
これ
|
Combining
Monads
](
homepages
.
inf
.
ed
.
ac
.
uk
/
wadler
/
papers
/
monadscomb
/
monadscomb
.
ps
)
[
メモ
](
http
://
cympfh
.
github
.
io
/
study
/
monad
.
txt
)
重複
`<-`
次
よう
定義
```
haskell
[
u
]
=
[
u
]
[
u
|
x
<-
ls
]
=
map
(\
x
->
u
)
ls
[
u
|
p
1
,
p
2
,
..
pn
,
q
]
=
concat
[[
u
|
q
]
|
p
1
,
p
2
..
pn
]
```
三
番目
再帰
部分
相当
の
順序
註意
順
`[
x
|
xs
<-
xss
,
x
<-
xs
]`
展開
これ
`
let
`
.
```
haskell
[
u
|
let
x
=
z
]
=
[
let
x
=
z
in
u
]
[
u
|
q
1
..
qn
,
let
x
=
z
]
=
[
let
x
=
z
in
u
|
q
1
..
qn
]
```
Predicate
こと
.
`
filter
`
簡単
,
```
haskell
[
y
|
x
<-
ls
,
test
]
```
```
scheme
(
filter
(
lambda
(???)
(
test
))
(
map
(
lambda
(
x
)
y
)
ls
))
```
`
test
`
何
述語
の
`
filter
`
外
`
x
`
項
よう
#
解決
法
モナド
なに
コード
先
```
haskell
[
y
|
x
<-
ls
,
test
]
```
```
scheme
(
let
((
ret
'()))
(
for
-
each
(
lambda
(
x
)
(
when
test
(
push
!
ret
x
)))
ls
))
```
展開
順
先ほど
```
haskell
[
x
|
xss
<-
xsss
,
xs
<-
xss
,
x
<-
xs
]
```
```
scheme
(
let
((
rec
'()))
(
for
-
each
(
lambda
(
xss
)
(
for
-
each
(
lambda
(
xs
)
(
for
-
each
(
lambda
(
x
)
(
push
!
ret
x
))
xs
))
xss
))
xsss
))
```
破壊
的
代入
push
!
おかげ
Predicate
ループ
スルー
(
continue
)
#
コード
<
script
src
="
https
://
gist
.
github
.
com
/
cympfh
/
47
d
8592
c
0912481
e
580
a
.
js
"></
script
>
