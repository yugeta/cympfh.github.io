2014
年
7
月
23
日
水曜日
18
:
47
:
50
JST
===
call
/
cc
,
coroutine
---
goal
:
```
scheme
(
define
(
f
)
(
yield
0
)
(
yield
1
)
(
return
2
))
```
return
全体
値
そこ
yield
続き
値
```
scheme
(
f
)
;
=>
0
(
f
)
;
=>
1
(
f
)
;
=>
2
(
f
)
;
=>
2
(
f
)
;
=>
2
```
よう
call
/
cc
自己
書き換え
解法
---
```
scheme
(
define
(
f
)
(
let
/
cc
return
(
let
/
cc
br
(
set
!
f
(
lambda
()
(
br
)))
(
return
0
))
(
let
/
cc
br
(
set
!
f
(
lambda
()
(
br
)))
(
return
1
))
(
return
2
)
))
```
`
return
`
(
f
)
大域
脱出
1
目
`
br
`
```
scheme
(
let
/
cc
br
(
set
!
g
(
lambda
()
(
br
)))
(
return
1
))
(
return
2
)
```
2
目
`
br
`
```
scheme
(
return
2
)
```
継続
次
よう
```
gosh
>
(
f
)
0
gosh
>
(
f
)
1
gosh
>
(
f
)
2
gosh
>
(
f
)
2
gosh
>
(
f
)
2
```
マクロ
---
よう
マクロ
```
scheme
(
define
-
macro
(
coroutine
f
.
bodies
)
(
define
(
rewrite
-
yield
exp
)
(
cond
((
and
(
pair
?
exp
)
(
equal
?
(
car
exp
)
'
yield
))
`(
let
/
cc
br
(
set
!
,
f
(
lambda
()
(
br
)))
(
return
,@(
cdr
exp
))))
((
list
?
exp
)
(
print
exp
)
(
map
rewrite
-
yield
exp
))
(
else
exp
)))
`(
define
(,
f
)
(
let
/
cc
return
,@(
map
rewrite
-
yield
bodies
))))
(
coroutine
f
(
begin
(
yield
-
1
)
(
yield
0
))
(
yield
1
)
(
return
2
))
```
```
gosh
>
(
f
)
-
1
gosh
>
(
f
)
0
gosh
>
(
f
)
1
gosh
>
(
f
)
2
gosh
>
(
f
)
2
gosh
>
(
f
)
2
```
無限
yield
---
使い方
```
scheme
(
coroutine
g
(
let
loop
((
i
0
))
(
yield
i
)
(
loop
(+
i
1
)))
(
return
#
f
))
```
```
gosh
>
(
g
)
0
gosh
>
(
g
)
1
gosh
>
(
g
)
2
gosh
>
(
g
)
3
gosh
>
(
g
)
4
gosh
>
```
