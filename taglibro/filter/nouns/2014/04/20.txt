2014
年
4
月
20
日
日曜日
00
:
30
:
08
JST
```
haskell
data
Tree
=
L
|
N
Int
Tree
Tree
deriving
Show
--
ー
木
生成
range
::
Int
->
Int
->
Tree
range
i
m
|
i
>=
m
=
L
|
otherwise
=
N
i
(
range
(
i
*
2
+
1
)
m
)
(
range
(
i
*
2
+
2
)
m
)
bfs
::
Tree
->
[
Tree
]
bfs
tree
=
q
where
q
=
tree
:
walk
q
::
[
Tree
]
walk
::
[
Tree
]
->
[
Tree
]
walk
(
L
:
_)
=
[
L
]
walk
((
N
value
left
right
)
:
rest
)
=
left
:
right
:
walk
rest
main
=
do
--
print
a
--
木
--
print
ls
--
順
(
木
)
print
$
map
just
ls
--
木の根
ノード
--
doSomething
(
fromJust
$
isJust
$
map
just
ls
)
順
(
無限
リスト
)
doSomething
大域
脱出
こと
末尾
再帰
where
a
=
range
0
16
ls
=
bfs
a
just
L
=
Nothing
just
(
N
x
_
_)
=
Just
x
```
