[
Project
Euler
-
Problem
48
](
http
://
projecteuler
.
net
/
problem
=
48
)
```
haskell
main
=
print
$
foldl
plus
0
$
map
self
_
pow
[
1
..
1000
]
where
plus
a
b
=
(
a
+
b
)
`
mod
`
rr
self
_
pow
n
=
pow
n
n
pow
n
0
=
1
pow
n
1
=
n
`
mod
`
rr
pow
n
m
=
if
m
`
mod
`
2
==
0
then
(
mod
((
pow
n
(
div
m
2
))
^
2
)
rr
)
else
(
mod
(
n
*
((
pow
n
(
div
m
2
))
^
2
))
rr
)
rr
=
10000000000
```
```
scheme
(
letrec
((
rr
10000000000
)
(
plus
(^
(
a
b
)
(
modulo
(+
a
b
)
rr
)))
(
pow
(^
(
n
m
)
(
cond
[(=
m
0
)
1
]
[(=
m
1
)
(
modulo
n
rr
)]
[(
zero
?
(
modulo
m
2
))
(
mod
(
expt
(
pow
n
(
div
m
2
))
2
)
rr
)]
[
else
(
mod
(*
(
expt
(
pow
n
(
div
m
2
))
2
)
n
)
rr
)])))
(
self
_
pow
(^
n
(
pow
n
n
)))
)
(
display
(
fold
plus
0
(
map
self
_
pow
(
iota
1000
1
))))
)
```
最後
行
の
gauche
0
.
9
.
3
標準
$
マクロ
```
scheme
($
display
$
fold
plus
0
$
map
self
_
pow
$
iota
1000
1
)
)
```
SRFI
-
49
もの
S
式
代わり
I
式
I
式
I
インデント
I
これ
極端
の
そう
ノート
手書き
擬似
コード
とき
lisp
こと
時
S
式
I
式
折衷
```
scheme
;
let
多
相
(
let
1
id
(^
x
x
)
(
id
id
)
)
;
謎
(
ML
型
推論
失敗
)
((^
f
(
f
f
))
(^
x
x
))
```
