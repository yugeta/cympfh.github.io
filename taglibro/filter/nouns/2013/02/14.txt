日付
管理
信用
一つ
上
人
卒論
発表
会見
誰
自由
見聞き
カンジ
ん
日付
場所
どこ
部外
者
修士
論文
自分
場所
こと
発表
ムリ
研究
室
次第
とも
---
Maybe
モナド
scheme
[
Monad
in
Scheme
(
2
)
-
moratorium
](
http
://
d
.
hatena
.
ne
.
jp
/
kzk
/
20050902
)
パクリ
ん
の
丸
写し
意味
自分
重要
/
scheme
/
monad
.
scm
.
txt
の
スケッチ
他人
目次
===
*
私
モナド
知識
*
実装
スケッチ
*
私
モナド
知識
---
Maybe
モナド
構成
の
return
>>=
,
あと
最後
中身
為
M
.
あと
失敗
為
fail
fail
判定
述語
fail
?.
M
の
(
return
1
)
1
何
中身
1
むき出し
もの
GHCi
実験
```
haskell
Prelude
>
return
1
1
```
表示
ん
```
haskell
Prelude
>
let
a
=
return
1
<
interactive
>:
20
:
9
:
Ambiguous
type
variable
`
m
0
'
in
the
constraint
:
(
Monad
m
0
)
arising
from
a
use
of
`
return
'
Probable
fix
:
add
a
type
signature
that
fixes
these
type
variable
(
s
)
In
the
expression
:
return
1
In
an
equation
for
`
a
':
a
=
return
1
```
return
1
何
モナド
の
型
文脈
やつ
```
haskell
Prelude
>
let
a
=
return
1
::
Maybe
Int
Prelude
>
a
Just
1
Prelude
>
let
a
=
return
1
::
[
Int
]
Prelude
>
a
[
1
]
```
(
::
Maybe
Int
)
修飾
子
つもり
M
定義
よう
実行
ここ
Scheme
コード
以下
gosh
実験
結果
はじめ
想定
通り
```
scheme
gosh
>
(
return
1
)
#<
closure
>
gosh
>
(
M
(
return
1
))
1
gosh
>
(
M
(
(
return
1
)
>>=
(^
x
(
return
2
))
))
2
gosh
>
(
M
(
(
return
1
)
>>=
(^
x
(
return
2
))
>>=
(^
x
(
return
3
))
))
3
```
S
式
律儀
の
bind
```
scheme
(>>=
(>>=
(
return
1
)
(^
x
(
return
...)))
>>=
(^
x
(
return
...)))
```
つまり
```
scheme
(
define
(>>=
m
f
)
...
)
```
[
howm
wiki
-
モナド
](
http
://
howm
.
sourceforge
.
jp
/
cgi
-
bin
/
hiki
/
hiki
.
cgi
?
Monad
)
ここ
実装
はじめ
方
[
Monad
in
Scheme
(
2
)
-
moratorium
](
http
://
d
.
hatena
.
ne
.
jp
/
kzk
/
20050902
)
(
m
>>=
f
>>=
g
>>=
h
...)
書き方
想定
私
記事
モナド
実装
ノート
人間
体
夜ふかし
よう
一
日
周期
24
時間
こと
後ろ
こと
容易
の
逆
前
こと
私
一
週間
ズラ
結果
昼
12
時
過ぎ
夜中
1
時
睡眠
時間
外
モナド
実装
部分
自分
一
人
発想
の
(
m
>>=
f
>>=
g
)
(
m
>>=
f
>>=
g
>>=
h
)
自然
簡単
(
m
>>=
f
)
反省
おかげ
時間
fail
一番
最後
実装
修正
fail
よう
gosh
>
(
M
(
(
return
1
)
>>=
fail
>>=
(^
x
(
return
3
))
))
Nothing
fail
あと
実行
もの
return
結果
影響
始め
引数
評価
時
以外
評価
こと
実装
スケッチ
---
私
ため
裏
紙
ラムダ
式
精一杯
何
の
言葉
```
scheme
(
define
(
return
x
)
```
x
もの
の
ローカル
変数
定義
こと
```
scheme
(
lambda
(
f
)
(
f
x
))
```
よう
ラムダ
式
return
もの
```
scheme
(
define
(
my
-
cons
x
y
)
(
lambda
(
f
)
(
f
x
y
)))
```
の
これ
定番
my
-
cons
my
-
car
,
my
-
cdr
簡単
cons
car
,
cdr
よう
return
M
M
return
もの
```
scheme
(
define
(
M
m
)
;
m
<-
(
return
1
)
(
m
(
lambda
(
x
)
x
)))
```
簡単
bind
実質
何
の
ベータ
簡約
様子
((
return
1
)
>>=
(^
x
(
return
2
)))
->
(>>=
1
(
list
(^
x
(
return
2
))))
->
((^
x
(
return
2
))
1
)
->
(
return
2
)
調子
>>=
ひとつ
(
return
1
)
>>=
(^
x
(
return
2
))
>>=
(^
x
(
return
3
))
->
(>>=
1
(
list
(^
x
(
return
2
))
>>=
(^
x
(
return
3
))))
->
((
return
2
)
>>=
(^
x
(
return
3
)))
>>=
中
ため
(
return
1
)
>>=
..
(>>=
1
..)
よう
```
scheme
(>>=
1
ls
)
```
```
scheme
(
let
1
op
(
car
ls
)
(
apply
(
op
ls
1
)
ls
))
```
scheme
return
今
1
引数
よう
ラムダ
式
こと
ここ
(>>=
..)
複数
値
こと
>>=
実行
書き換え
必要
```
scheme
(
define
(
return
x
)
(
lambda
(
f
.
rest
)
(
f
x
rest
)))
```
これ
`((
return
1
)
>>=
(^
x
...))`
`(>>=
1
((^
x
..)))`
>>=
二
引数
リスト
の
注意
```
scheme
(
define
(>>=
x
ls
)
(
apply
((
car
ls
)
x
)
(
cdr
ls
)))
```
これ
`(>>=
1
((^
x
..)))`
`(
apply
((^
x
..)
1
)
'())`
apply
二
引数
残り
'(>>=
(^
x
...))
予定
>>=
一つ
並び
空
とき
apply
エラー
null
?
分岐
必要
私
こと
これ
ひと
通り
全て
(
fail
)
(
return
'
Nothing
)
述語
(
define
fail
?
(
pa
$
equal
'
Nothing
))
用意
>>=
中
(>>=
x
ls
)
x
fail
?
#
t
(
fail
)
以上
こと
*
```
scheme
gosh
>
zero
#<
closure
(
return
return
)>
gosh
>
(
M
zero
)
0
gosh
>
(
M
one
)
1
gosh
>
succ
#<
closure
succ
>
gosh
>
pred
#<
closure
pred
>
gosh
>
(
M
(
one
>>=
succ
))
2
gosh
>
(
M
(
one
>>=
succ
>>=
succ
))
3
gosh
>
(
M
(
one
>>=
succ
>>=
fail
>>=
succ
))
Nothing
gosh
>
(
define
(
find
x
)
(
let
1
result
(
assoc
x
'((
1
.
minamike
)
(
3
.
okaeri
)
(
4
.
tadaima
)))
(
if
result
($
return
$
cdr
result
)
(
fail
))
))
find
gosh
>
(
M
(
one
>>=
find
))
minamike
gosh
>
(
M
(
one
>>=
succ
>>=
find
))
Nothing
gosh
>
(
M
(
one
>>=
succ
>>=
succ
>>=
find
))
okaeri
gosh
>
(
M
(
one
>>=
succ
>>=
succ
>>=
pred
>>=
find
))
Nothing
```
モナド
途中
失敗
事例
有用
性
みんな
ゼロ
