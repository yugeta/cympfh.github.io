Wed
Jun
5
11
:
34
:
38
JST
2013
scheme
into
tex
```
bash
gosh
report
.
scm
>
report
.
tex
```
文字
列
ダブルクオーテーション
の
実用
性
疑問
latex
8
分割
印刷
beamer
場合
非常
有用
```
make
split
8
:
platex
$(
FILE
).
tex
dvips
$(
FILE
).
dvi
>
$(
FILE
).
ps
pstops
-
pa
4
'
8
:
0
@.
7
(
1
cm
,
22
.
2
cm
)+
1
@.
7
(
11
.
2
cm
,
22
.
2
cm
)+
2
@.
7
(
1
cm
,
14
.
9
cm
)+
3
@.
7
(
11
.
2
cm
,
14
.
9
cm
)+
4
@.
7
(
1
cm
,
7
.
7
cm
)+
5
@.
7
(
11
.
2
cm
,
7
.
7
cm
)+
6
@.
7
(
1
cm
,
0
.
4
cm
)+
7
@.
7
(
11
.
2
cm
,
0
.
4
cm
)'
$(
FILE
).
ps
|
sed
'
s
/
363
273
/
596
842
/
g
'
>
$(
FILE
)-
8
.
ps
```
意味
普通
latex
環境
platex
,
dvips
pstops
今
必要
以下
現時点
tex
.
scm
```
scheme
(
define
-
syntax
tex
(
syntax
-
rules
()
((
tex
x
...)
(
map
display
(
list
x
...)))))
;;;;
(
define
(
x
-
append
.
args
)
(
apply
string
-
append
(
map
x
->
string
args
)))
(
define
(
x
-
join
ls
del
)
(
string
-
join
(
map
x
->
string
ls
)
del
))
;
keyword
name
=>
\
name
(
define
(
keyword
name
)
(
x
-
append
"\\"
name
"
"))
(
define
yen
keyword
)
;
keyword
/
option
name
option
=>
\
name
[
option
]
(
define
(
keyword
/
option
name
option
)
(
x
-
append
"\\"
name
"["
option
"]"))
;
tag
name
hoge
hige
=>
\
name
{
hoge
hige
}
(
define
(
tag
name
.
args
)
(
let
1
contents
(
x
-
join
args
"
")
(
x
-
append
"\\"
name
"{"
contents
"}")))
(
define
(
tag
2
name
arg
1
arg
2
)
(
x
-
append
"\\"
name
"{"
arg
1
"}{"
arg
2
"}"))
;
\
name
[
option
]{
hoge
hare
}
(
define
(
tag
/
option
name
option
.
args
)
(
let
1
contents
(
x
-
join
args
"
")
(
x
-
append
"\\"
name
"["
option
"]"
"{"
contents
"}")))
;
env
name
hoge
hige
=>
\
begin
{
name
}
hoge
hige
\
end
{
name
}
(
define
(
env
name
.
args
)
(
let
1
contents
(
x
-
join
args
"\
n
")
(
x
-
append
"\\
begin
{"
name
"}\
n
"
contents
"\
n
\\
end
{"
name
"}\
n
")))
(
define
(
env
2
name
option
.
args
)
(
let
1
contents
(
x
-
join
args
"\
n
")
(
x
-
append
"\\
begin
{"
name
"}{"
option
"}\
n
"
contents
"\
n
\\
end
{"
name
"}\
n
")))
;;;;
tag
(
define
(
jsarticle
.
args
)
(
if
(
zero
?
(
length
args
))
(
tag
'
documentclass
'
jsarticle
)
(
let
1
options
(
x
-
join
args
",")
(
tag
/
option
'
documentclass
options
'
jsarticle
))))
(
define
(
beamer
.
args
)
(
x
-
append
(
if
(
zero
?
(
length
args
))
(
tag
'
documentclass
'
beamer
)
(
let
1
options
(
x
-
join
args
",")
(
tag
/
option
'
documentclass
options
'
beamer
)))
"\\
setbeamertemplate
{
navigation
symbols
}{}
"))
(
define
(
usetheme
.
args
)
(
tag
'
usetheme
(
x
-
join
args
",")))
(
define
(
usefonttheme
.
args
)
(
tag
'
usefonttheme
(
x
-
join
args
",")))
(
define
(
usepackage
.
args
)
(
tag
'
usepackage
(
x
-
join
args
",")))
(
define
(
title
.
args
)
(
apply
tag
'
title
args
))
(
define
(
author
.
args
)
(
apply
tag
'
author
args
))
(
define
(
frametitle
.
args
)
(
apply
tag
'
frametitle
args
))
(
define
(
date
.
args
)
(
apply
tag
'
date
args
))
(
define
(
thanks
.
args
)
(
apply
tag
'
thanks
args
))
(
define
thanx
thanks
)
(
define
(
sqrt
x
)
(
tag
'
sqrt
x
))
(
define
(
hat
x
)
(
tag
'
hat
x
))
(
define
(
lnot
x
)
(
tag
'
lnot
x
))
(
define
(-->
x
)
(
tag
'
xrightarrow
x
))
(
define
(
bra
.
args
)
(
tag
'
bra
(
x
-
join
args
",
")))
(
define
(
ket
.
args
)
(
tag
'
ket
(
x
-
join
args
",
")))
(
define
(
braket
x
y
)
(
tag
'
braket
(
x
-
append
x
"|"
y
)))
(
define
(
over
x
y
)
(
tag
2
'
overset
x
y
))
(
define
(
frac
a
b
)
(
tag
2
'
frac
a
b
))
(
define
/
frac
)
(
define
sum
(
let
1
pre
"\\
displaystyle
\\
sum
"
(
case
-
lambda
(()
(
x
-
append
pre
))
((
sub
)
(
x
-
append
pre
"_{"
sub
"}"))
((
sub
sup
)
(
x
-
append
pre
"_{"
sub
"}"
"^{"
sup
"}")))))
(
define
(
text
.
args
)
(
let
1
contents
(
x
-
join
args
"
")
(
tag
'
text
contents
)))
;;;
env
(
define
(
document
.
args
)
(
apply
env
'
document
args
))
(
define
(
enumerate
.
args
)
(
apply
env
'
enumerate
args
))
(
define
(
eqnarray
.
args
)
(
apply
env
'
eqnarray
args
))
(
define
(
eqnarray
*
.
args
)
(
apply
env
'
eqnarray
*
args
))
(
define
(
equation
.
args
)
(
apply
env
'
equation
args
))
(
define
(
theorem
.
args
)
(
apply
env
'
theorem
args
))
(
define
(
proof
.
args
)
(
apply
env
'
proof
args
))
(
define
(
frame
.
args
)
(
cond
((
equal
?
(
car
args
)
#
t
)
(
apply
env
2
'
frame
(
cadr
args
)
(
cddr
args
)))
(
else
(
apply
env
'
frame
args
))))
;;;
keywords
(
define
titlepage
"\\
frame
{\\
titlepage
}")
(
define
maketitle
(
keyword
'
maketitle
))
(
define
newline
(
keyword
'
newline
))
(
define
emptyline
"\\;\
n
\
n
")
(
define
today
(
keyword
'
today
))
(
define
|\\|
"\\\\")
(
define
&
"&")
(
define
in
(
keyword
'
in
))
(
define
subset
(
keyword
'
subset
))
(
define
forall
(
keyword
'
forall
))
(
define
exists
(
keyword
'
exists
))
(
define
dots
(
keyword
'
dots
))
(
define
pm
(
keyword
'
pm
))
(
define
dagger
(
keyword
'
dagger
))
(
define
ne
(
keyword
'
ne
))
(
define
!=
ne
)
(
define
le
(
keyword
'
le
))
(
define
ge
(
keyword
'
ge
))
(
define
===
(
keyword
'
equiv
))
(
define
->
(
keyword
'
rightarrow
))
(
define
<-
(
keyword
'
leftarrow
))
(
define
=>
(
keyword
'
Rightarrow
))
(
define
<=>
(
keyword
'
Leftrightarrow
))
(
define
alpha
(
yen
'
alpha
))
(
define
beta
(
yen
'
beta
))
(
define
kappa
(
yen
'
kappa
))
(
define
varphi
(
yen
'
varphi
))
(
define
(
diff
x
y
)
(
x
-
append
x
(
keyword
'
setminus
)
y
))
(
define
(
max
.
args
)
(
x
-
append
(
keyword
'
max
)
"\\{"
(
x
-
join
args
",")
"\\}"))
(
define
(
item
.
args
)
(
define
(
opt
a
)
(
cond
((
string
?
a
)
`("["
,
a
"]"))
((
number
?
a
)
`("<"
,
a
"->"))
(
else
'())))
(
apply
x
-
append
(
keyword
'
item
)
(
concatenate
(
map
opt
args
))))
(
define
(
alert
.
args
)
(
let
1
contents
(
x
-
join
args
"
")
(
tag
'
alert
contents
)))
;;
others
(
define
(
eqn
.
args
)
(
let
1
contents
(
x
-
join
args
"
")
(
x
-
append
"\\[
"
contents
"
\\]")))
(
define
($
.
args
)
(
let
1
contents
(
x
-
join
args
"
")
(
x
-
append
"
$"
contents
"$
")))
(
define
(^
x
t
)
(
x
-
append
x
"^{"
t
"}"))
(
define
(_
x
t
)
(
x
-
append
x
"_{"
t
"}"))
(
define
(+
.
args
)
(
x
-
join
args
"+"))
(
define
(*
.
args
)
(
x
-
join
args
"
"))
(
define
(
times
.
args
)
(
x
-
join
args
(
keyword
'
times
)))
(
define
(-
.
args
)
(
if
(=
(
length
args
)
1
)
(
x
-
append
"-"
(
car
args
))
(
paren
(
x
-
join
args
"-"))))
(
define
++
"+\\
hbox
to
3
pt
{\\
hss
+}")
(
define
(
paren
.
args
)
(
let
1
contents
(
x
-
join
args
"
")
(
x
-
append
"("
contents
")")))
(
define
(
comma
.
args
)
(
x
-
join
args
",
"))
```
---
Wed
Jun
5
15
:
23
:
24
JST
2013
#
プロジェクター
実験
先週
xfce
パソコン
プロジェクタ
モニタ
検知
"
output
on
"
別
パソコン
xfce
xrandr
よう
気
```
bash
#
の
モニタ
出力
デバイス
一覧
$
xrandr
-
q
Screen
0
:
minimum
320
x
200
,
current
1280
x
800
,
maximum
8192
x
8192
LVDS
1
connected
1280
x
800
+
0
+
0
(
normal
left
inverted
right
x
axis
y
axis
)
286
mm
x
179
mm
1280
x
800
60
.
5
*+
1024
x
768
60
.
0
800
x
600
60
.
3
56
.
2
640
x
480
59
.
9
VGA
1
disconnected
(
normal
left
inverted
right
x
axis
y
axis
)
HDMI
1
disconnected
(
normal
left
inverted
right
x
axis
y
axis
)
DP
1
disconnected
(
normal
left
inverted
right
x
axis
y
axis
)
HDMI
2
disconnected
(
normal
left
inverted
right
x
axis
y
axis
)
DP
2
disconnected
(
normal
left
inverted
right
x
axis
y
axis
)
DP
3
disconnected
(
normal
left
inverted
right
x
axis
y
axis
)
TV
1
disconnected
(
normal
left
inverted
right
x
axis
y
axis
)
```
LVDS
1
組み込み
ノート
パソコン
モニタ
VGA
1
私
プロジェクタ
出力
穴
```
bash
#
私
ノート
パソコン
最高
解像度
$
xrandr
--
output
LVDS
1
--
mode
1280
x
800
```
--
mode
後
タブ
補完
解像度
一覧
```
bash
#
これ
大丈夫
$
xrandr
--
output
LVDS
1
--
auto
#
プロジェクタ
解像度
$
xrandr
--
output
LVDS
1
--
mode
1024
x
768
#
プロジェクタ
出力
$
xrandr
--
output
VGA
1
--
mode
1024
x
768
#
別
解像度
$
xrandr
--
output
VGA
1
--
mode
800
x
600
#
今度
$
xrandr
--
output
VGA
1
--
mode
1024
x
768
```
