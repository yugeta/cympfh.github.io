Mon
Jul
22
16
:
30
:
14
JST
2013
syntax
-
rules
キーワード
よう
もの
区切り
```
scheme
(
define
-
syntax
two
-
list
(
syntax
-
rules
(
delminator
)
((
two
-
list
x
...
delminator
y
...)
(
values
(
list
x
...)
(
list
y
...)))))
```
...
の
直後
括弧
よう
場所
上
コンパイル
エラー
大体
上
みたい
こと
`(
two
-
list
1
2
3
delminator
4
5
)`
=>
`(
values
(
list
1
2
3
)
(
list
4
5
))`
syntax
-
rules
それ
実現
コード
そう
.
現実
的
`(
two
-
list
(
1
2
3
)
delminator
(
4
5
))`
解決
括弧
いし
マクロ
相互
再帰
コード
試行
錯誤
define
-
macro
引数
クオート
状態
普通
scheme
手続き
操作
何
```
scheme
(
use
srfi
-
1
)
(
define
-
macro
(
two
-
list
.
ls
)
(
receive
(
a
b
)
(
split
-
at
ls
(
list
-
index
(
cut
equal
?
'*
<>)
ls
))
`(
values
(
list
,@
a
)
(
list
,@(
cdr
b
)))))
```
```
scheme
gosh
>
(
macroexpand
'(
two
-
list
1
2
3
*
4
5
))
(
values
(
list
1
2
3
)
(
list
4
5
))
gosh
>
(
two
-
list
1
2
3
*
4
5
)
(
1
2
3
)
(
4
5
)
```
の
これ
```
scheme
gosh
>
(
begin
1
2
3
)
3
gosh
>
(
begin
1
2
a
where
(
a
3
))
3
```
Haskell
where
.
`(
begin
a
...
where
(
var
val
)
...)`
の
`(
let
*
((
var
val
)
...)
a
...)`
変換
let
*
where
後
定義
変数
相互
参照
わけ
注意
コード
以下
通り
begin
オーバー
ロード
```
scheme
(
use
srfi
-
1
)
(
define
-
macro
(
begin
.
body
)
(
let
1
idx
(
list
-
index
(
cut
equal
?
'
where
<>)
body
)
(
if
idx
(
receive
(
a
b
)
(
split
-
at
body
idx
)
`(
let
*
,(
cdr
b
)
,@
a
))
`(
let
*
()
,@
body
))))
```
