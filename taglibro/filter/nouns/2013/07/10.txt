Wed
Jul
10
00
:
54
:
17
JST
2013
参照
透過
性
メモ
化
誰
Haskell
メモ
化
デフォルト
場
一緒
こと
.
入出力
参照
透過
性
Haskell
ん
,
Land
of
Lisp
ヤバ
メモ
化
こと
.
メモ
化
メモ
(
cache
)
ハッシュ
テーブル
提案
手法
---
関数
そのもの
データ
保存
ため
もの
こと
Haskell
経路
探索
問題
課題
マップ
データ
関数
こと
の
私
の
```
haskell
--
複数
ブロック
座標
b
=
[[
1
,
3
],
[
2
,
1
],
[
5
,
3
],
[
5
,
6
]]
```
```
haskell
--
私
b
1
3
=
True
b
2
1
=
True
b
5
3
=
True
b
5
6
=
True
b
_
_
=
False
```
リスト
具体
的
データ
取得
の
面倒
getter
関数
定義
そ
線形
時間
私
データ
直接
getter
関数
こと
人
コード
本題
```
scheme
;;
普通
メモ
化
関数
(
define
fib
(
let
1
memo
(
make
-
hash
-
table
)
(
lambda
(
n
)
(
cond
((<=
n
1
)
n
)
((
hash
-
table
-
get
memo
n
#
f
)
=>
values
)
(
else
(
let
1
ans
(+
(
fib
(-
n
1
))
(
fib
(-
n
2
)))
(
hash
-
table
-
put
!
memo
n
ans
)
ans
))))))
```
レキシカルスコープ
変数
memo
ハッシュ
テーブル
作成
副作用
満載
キャッシュ
更新
提案
手法
---
ハッシュ
テーブル
構造
利用
代わり
(
memo
n
)
手続き
(
memo
n
)
(
fib
n
)
答え
#
f
.
最初
#
f
定数
関数
.
時
memo
手続き
自体
更新
```
scheme
(
cond
((
memo
n
)
=>
values
)
;
values
恒等
関数
(
else
(
update
-
memo
!
...)))
```
感じ
具体
的
フィボナッチ
計算
の
下
```
scheme
(
define
(
fib
2
n
)
(
define
(
memo
n
)
#
f
)
(
cond
((<=
n
1
)
n
)
((
memo
n
)
=>
values
)
(
else
(
let
((
ans
(+
(
fib
2
(-
n
1
))
(
fib
2
(-
n
2
))))
(
memo
0
memo
))
(
set
!
memo
(
lambda
(
m
)
(
if
(=
m
n
)
ans
(
memo
0
m
))))
ans
))))
```
`(
hash
-
table
-
get
memo
n
#
f
)`
ゲッター
`(
memo
n
)`
簡単
の
手続き
更新
トコ
最初
fib
2
fib
fib
の
はじめ
方
fib
fib
2
速度
ー
ん
関数
毎回
それ
関数
更新
ことし
残念
非常
ただ
冗談
こと
