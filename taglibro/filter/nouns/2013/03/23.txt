Sat
Mar
23
18
:
32
:
54
JST
2013
#
State
モナド
State
モナド
結局
値
状態
タプル
大げさ
こと
こと
Control
.
Arrow
昨日
読解
これ
こと
こと
大げさ
分
Arrow
スタック
実装
(
値
スタック
)
タプル
>>>
```
haskell
--
import
Control
.
Monad
.
State
import
Control
.
Arrow
(|>)
x
f
=
f
x
infixl
0
|>
start
::
(
Int
,
[
Int
])
start
=
(
0
,
[])
push
::
Int
->
(
a
,
[
Int
])
->
(
Int
,
[
Int
])
push
n
=
const
n
***
(
n
:)
pop
::
(
a
,
[
Int
])
->
(
Int
,
[
Int
])
pop
(_,
(
x
:
xs
))
=
(
x
,
xs
)
```
```
haskell
*
Main
>
start
|>
push
1
(
1
,[
1
])
*
Main
>
start
|>
push
1
>>>
push
2
(
2
,[
2
,
1
])
*
Main
>
start
|>
push
1
>>>
push
2
>>>
pop
(
2
,[
1
])
```
問題
いくつ
Arrow
コード
```
haskell
let
f
=
hoge
>>
hage
>>
moge
f
3
```
みたい
```
haskell
(
hoge
>>>
hage
>>>
moge
)
3
```
かっこ
上
|>
```
haskell
3
|>
hoge
>>>
hage
>>>
moge
```
パイプライン
|>
左
結合
```
haskell
3
|>
hoge
|>
hage
|>
moge
```
意味
個人
的
こちら
ほう
好き
スタック
スタック
上
計算
機
足し算
二
度
ポップ
の
プッシュ
ポップ
もの
`(
a
,
state
)`
a
保持
二
度目
ポップ
a
破棄
別
もの
必要
これ
Arrow
パイプライン
分岐
```
haskell
*
Main
>
start
|>
push
1
|>
push
2
|>
pop
(
2
,[
1
])
*
Main
>
start
|>
push
1
|>
push
2
|>
pop
|>
fst
&&&
pop
(
2
,(
1
,[]))
*
Main
>
start
|>
push
1
|>
push
2
|>
pop
|>
fst
&&&
pop
|>
(\(
x
,
ys
@(
y
,
s
))
->
push
(
x
+
y
)
ys
)
(
3
,[
3
])
```
app
存在
直接
タプル
よう
関数
方
コード
次
よう
汎用
スタック
上
二
項
演算
子
```
haskell
op
f
=
pop
>>>
fst
&&&
id
>>>
second
pop
>>>
(\(
x
,
ys
@(
y
,
s
))
->
push
(
f
x
y
)
ys
)
add
=
op
(+)
sub
=
op
(-)
mul
=
op
(*)
*
Main
>
start
|>
push
2
|>
push
3
|>
add
(
5
,[
5
])
*
Main
>
start
|>
push
2
|>
push
3
|>
push
7
|>
add
|>
mul
(
20
,[
20
])
```
頭
runState
の
コレ
普通
